好的！我将为你系统总结三数之和与四数之和的核心解法、异同点及关键技巧，帮你清晰梳理这两类问题的解题思路。

# 三数之和 & 四数之和 核心总结
## 一、核心解法：排序 + 双指针
### 1. 三数之和（目标和为0）
#### 核心逻辑
- **固定第一个数**，将问题转化为**两数之和**；
- 用双指针（`second` 从左、`third` 从右）遍历剩余元素，根据和的大小调整指针。

#### 关键步骤
```python
def threeSum(nums):
    nums.sort()
    res = []
    n = len(nums)
    for first in range(n-2):
        # 去重：跳过重复的第一个数
        if first > 0 and nums[first] == nums[first-1]:
            continue
        second, third = first+1, n-1
        while second < third:
            s = nums[first] + nums[second] + nums[third]
            if s == 0:
                res.append([nums[first], nums[second], nums[third]])
                # 去重：跳过重复的second/third
                while second < third and nums[second] == nums[second+1]:
                    second +=1
                while second < third and nums[third] == nums[third-1]:
                    third -=1
                second +=1
                third -=1
            elif s < 0:
                second +=1  # 和太小，左指针右移
            else:
                third -=1   # 和太大，右指针左移
    return res
```

#### 优化技巧
- `third` 指针可复用位置（`second` 递增时不重置），减少冗余移动；
- 提前剪枝（如 `nums[first] > 0` 时直接break）。

### 2. 四数之和（目标和为任意值）
#### 核心逻辑
- **固定前两个数**，将问题转化为**两数之和**；
- 双指针逻辑与三数之和一致，仅多一层外层循环。

#### 关键步骤
```python
def fourSum(nums, target):
    nums.sort()
    res = []
    n = len(nums)
    for i in range(n-3):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        for j in range(i+1, n-2):
            if j > i+1 and nums[j] == nums[j-1]:
                continue
            k, l = j+1, n-1
            while k < l:
                s = nums[i] + nums[j] + nums[k] + nums[l]
                if s == target:
                    res.append([nums[i], nums[j], nums[k], nums[l]])
                    while k < l and nums[k] == nums[k+1]:
                        k +=1
                    while k < l and nums[l] == nums[l-1]:
                        l -=1
                    k +=1
                    l -=1
                elif s < target:
                    k +=1
                else:
                    l -=1
    return res
```

## 二、三数之和 vs 四数之和 异同点
| 维度                | 三数之和                          | 四数之和                          |
|---------------------|-----------------------------------|-----------------------------------|
| **外层循环数**      | 1层（固定1个数）                  | 2层（固定2个数）                  |
| **时间复杂度**      | $O(n^2)$                          | $O(n^3)$                          |
| **双指针范围**      | `first+1` 到 `n-1`                | `j+1` 到 `n-1`                    |
| **去重逻辑**        | 对`first`/`second`/`third`去重    | 对`i`/`j`/`k`/`l`去重             |
| **核心思想**        | 降维为两数之和                    | 降维为两数之和                    |

## 三、通用关键技巧
### 1. 排序的必要性
- 排序是双指针法的基础，让指针可根据和的大小定向移动；
- 排序同时为去重提供便利（重复元素相邻）。

### 2. 去重的正确姿势
- **固定数去重**：`if i > start and nums[i] == nums[i-1]: continue`；
- **双指针去重**：找到解后，跳过重复值（必须加 `left < right` 防越界）；
- **禁止过度去重**：非目标和场景（如最接近的三数之和）无需对双指针去重。

### 3. 指针移动规则
- 和小于目标值 → 左指针右移（增大和）；
- 和大于目标值 → 右指针左移（减小和）；
- 找到目标值 → 双指针同时移动（找下一组解）。

### 4. 边界优化
- 外层循环范围：三数之和 `range(n-2)`，四数之和 `range(n-3)`/`range(i+1, n-2)`；
- 双指针去重时必须加 `k < l` 判断，避免数组越界。

## 四、常见错误避坑
1. **重复组合**：未对固定数或双指针去重；
2. **数组越界**：双指针去重时未加边界判断；
3. **冗余计算**：将双指针初始化放在内层循环中（导致重复重置）；
4. **逻辑错误**：指针移动方向与和的大小关系搞反。

### 总结
1. **三数之和与四数之和的核心**：通过**排序+固定前k个数+双指针**，将问题降维为两数之和；
2. **差异仅在于外层循环层数**：三数之和1层外层循环，四数之和2层；
3. **通用技巧**：排序是基础、去重是关键、指针移动有规律。

记住：**降维思想+双指针法**是解决n数之和问题的万能钥匙！
